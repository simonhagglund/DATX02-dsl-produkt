TODO: Pixxorz, redo tangens

\section{Complex numbers}
\iffalse
Här är målet främst att introducera dsl som koncept och även introducera hur vi behandlar komplexa tal eftersom detta kommer återkomma mycket i texten. Vi gör detta genom att snabbt repetera komplexa tal. Vi antar dock att läsaren egentligen är bekväm med komplexa tal och att detta istället är en mjukstart för dsl, haskell och våra egna betäckningar.\\
\fi

In short, the complex numbers are an extension of the real numbers in the same way that the real numbers are an extension of the rational numbers. With the reals, we saw the addition of a number of constants(e, $\pi$, etc.).
This time around, we add imaginary numbers.


\subsection{The Imaginary Number Concept}
So what the heck are Imaginary numbers? Imaginary numbers are the pet project of some scientist who really really wanted a root to -1. This then turned into an entire field of study. No, we don't get it either. Luckily, we do at least know how to use them.

First, let's start with the definition:
\begin{align*}
    i = \sqrt{-1}
\end{align*}

And by extension:
\begin{align*}
    i^2 = -1
\end{align*}

From these humble beginnings, the rest of the field is born.
\vspace{5mm}

Second, let's deal with some syntax.

Imaginary numbers have an annoying tendency to show up alongside real numbers. As such, mathematicians have standardized complex numbers as being read ``a + bi.'' Rather than bother with this expression, however, we are going to ignore it and instead create our own using the power of programming:
\begin{code}
data Complex = Complex (Double, Double)
  deriving (Show)
\end{code}

This is the first step to creating a domain-specific Language; establishing how our `words' (or in this case numbers) are written. Note that the doubles are inherently inaccurate; they cannot provide more than an approximation of most non-integers(I.E. 2/3, e, $\pi$, etc.). Since we are more concerned with understanding the process than getting a strictly accurate answer, however, this simplification is quite alright.

Question though; why did we choose to put our doubles in round brackets? To help explain how we're actually going to use complex numbers going forwards (for the most part, anyway). Behold, the Argand diagram!

TODO: Coordinate/Argand pic goes here.

You may notice a certain similarity to coordinate planes. This is because they are essentially one and the same. Also note how we wrote our datatype to imitate how coordinates are usually written. We are very smart.

\subsection{Basic Operators}

For our first operators, let's just create a pair of functions that extract the real and imaginary parts of the Complex number. As can be seen in the picture above, the real numbers exist along the x-axis, and the imaginary ones exist along the y-axis. As such:
\begin{code}
whatsReal :: Complex -> Double
whatsReal (Complex (x,y)) = x

whatsImaginary :: Complex -> double
whatsImaginary (Complex (x,y)) = y
\end{code}

Well, that was easy enough. Next, let's define the most fundamental of all math operators: Addition. Please look at the picture below.

TODO: Add picture of two coordinates being added together here.

This is the first instance of our coordinate-esque DSL making calculation simple. We can clearly see that to add two Complex numbers together, we add reals to reals, and imaginaries to imaginaries. To wit:
\begin{code}
add :: Complex -> Complex -> Complex
add (Complex (r1,i1)) (Complex (r2,i2)) = (Complex (r1+r2,i1+i2))
\end{code}

Next, let's add subtraction. It works the exact same way as addition.
\begin{code}
sub :: Complex -> Complex -> Complex
sub (Complex (r1,i1)) (Complex (r2,i2)) = Complex (r1-r2,i1-i2)
\end{code}

\subsection{Imaginary Geometry}

Now, let's move on to the main reason why we chose to mimic coordinates when defining our datatype. No, it wasn't to simplify addition and subtraction. That was just a bonus.

The real reason is that it allows us to use complex numbers to express geometry. To do this, we'll need two core functions. First off, the absolute value.

Note that, since complex numbers exist on a plane rather than a line, we can't just turn them positive and call it a day. Instead, we'll have to call upon our good old friend Pythagoras:

TODO: Add picture of complex pythagoras here.

\begin{code}
absolute :: Complex -> Double
absolute (Complex (real,imaginary)) = sqrt (real^2 + imaginary^2)
\end{code}
Since squaring always result in positive values, there's no need to worry about whether the values started out positive or negative.\\
Let's move on to arguments, a.k.a. angles.

Pythagoras' theorem is not the only geometric rule that can be combined with Argand diagrams/coordinates. In fact, all of them can. Let's do some tangents. Except in Argand, the resulting value is called an argument rather than an angle.

Unlike regular angles, however, the standard way to express a complex argument, also known as the ''Principal Argument'' does not include a complete 360degree circle from positive real to positive real. Instead, the principal argument uses two scales from the positive reals to the negative reals. One covers positive imaginary values and gives arguments ranging from 0 to $/pi$. The other covers negative imaginaries and gives arguments ranging from 0 to $-/pi$. See picture below for clarity.

TODO: Add picture of the double-half-circles used to define principal arguments.

This complicates our calculations somewhat, but not by much. We'll simply have to split our function in two; one for each half-circle. The negative semi-circle can easily be managed by calculating its positive counterpart and then inverting it.
\begin{code} %% WIP %%
argument :: Complex -> Double
argument (Complex (real,imaginary))
  | imaginary >= 0  = atan (imaginary/real)
  | otherwise       = -atan (-imaginary/real)
    
arg :: Complex -> double
arg complex = argument complex
\end{code} %% Somebody please double-check the math on this, it wasn't the solution I found online %%
%% UPDATE: It's shit. Will rework.

Note that this function is currently undefined for numbers where the real component is 0, due to division by 0. This can be solved with three lines of code, but we're keeping things simple for readability.

The Absolute Value and the Principal Argument, with their powers combined, form an alternate way to express the ''position'' of a Complex number; by expressing the direction and distance from the origin. The later sections will have a field day exploring the possibilities of this.

\subsection{Advanced Operators}

There is one final function that awaits us; one final operator:\\ multiplication!\\
..\\
Ok, might not sound like much, but there's a reason why we're tackling it last.\\
Can you tell us how to multiply two Complex numbers, based on what we've been talking about so far?\\
..\\
The simple truth of the matter is, we can't. Each Domain-specific Language is, as the name suggests, only meant to express one domain. Our chosen domain was geometry, and we chose to express our Complex numbers as coordinates to aid with that.

That does not mean we can't build a function to multiply two Complex numbers, but it does mean we'll have to move outside the bounds of our DSL to accomplish it.

To wit; in regular math, complex numbers are normally written on the form ''a + bi'', I.E. reals + imaginaries. With that language in mind, basic algebra become a lot more intuitive. 'multiply Complex (r1,i1) Complex (r2,i2)' in our DSL becomes (r1 + i1)(r2 + i2). This can be solved the same way we solve any multiplication of additions; by multiplying each combination and adding the results:

TODO: Add a picture explaining basic multiplication.

As such, by cleverly switching languages, we can find solutions to problems that our current DSL struggles with.

We can now define an operator in our own DSL using the information provided by traditional algebra to reach a correct answer. There is still one annoying complication remaining, however; we've got one term containing $i^2$. How will we make that work with how we've defined our datatype? We never added a way to write powers!

Ach, if only there was a convenient comment regarding the definition of i that we brought up at the beginning of the section and fully expect you to have forgotten about.

TODO: Add a cheeky picture referring back to the definition of i :)

Oh wait, there is just such a thing! $i^2$ is the same as -1! We can now complete our final function and also operator.

\begin{code}
multiply :: Complex -> Complex -> Complex
multiply (Complex (r1,i1)) (Complex (r2,i2))
  = Complex (r1*r2 - i1*i2, r1*i2 + r2*i1)
\end{code}
Feel free to create a shortened version yourself this time. We'd do it for you, but we can't think of a fitting function name that doesn't sound silly.

\vspace{1cm}

As noted at the very top, complex numbers are an entire field of study. If we were to cover all there is to know about them, this section would take up a small library worth of text and require an actual budget to write. The above should be just enough to give a basic understanding of the concept, along with all associated operators used in the sections below. Just remember that the coordinate comparison, while undeniably useful, does not apply to every possible operation and you'll do fine.


\iffalse %% OLD %%
\begin{code}
data Complex = Complex (Double, Double)
  deriving (Show)
  
test1 = Complex (1,1)
test2 = Complex (3,4)

whatsReal :: Complex -> Double
whatsReal (Complex (x, y)) = x

whatsImaginary :: Complex -> Double
whatsImaginary (Complex (x, y)) = y

add :: Complex -> Complex -> Complex
add (Complex (r1,i1)) (Complex (r2,i2)) = (Complex (r1+r2,i1+i2))

sub :: Complex -> Complex -> Complex
sub (Complex (r1,i1)) (Complex (r2,i2)) = Complex (r1-r2,i1-i2)

absolute :: Complex -> Double
absolute (Complex (real,imaginary)) = sqrt (real^2 + imaginary^2)

argument :: Complex -> Double
argument (Complex (real,imaginary))
  | imaginary >= 0  = atan (imaginary/real)
  | otherwise       = -atan (-imaginary/real)
  
multiply :: Complex -> Complex -> Complex
multiply (Complex (r1,i1)) (Complex (r2,i2))
  = Complex (r1*r2 - i1*i2, r1*i2 + r2*i1)

\end{code}
\fi